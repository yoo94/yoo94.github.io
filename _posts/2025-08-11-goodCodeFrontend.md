---
layout: post
title: "토스 FE의 좋은 코딩이란?"
summary: "토스의 frontend-fundamentals + 내생각"
author: yoo94
date: "2025-08-11 5:30:23 +0530"
category: DevLog
keywords: 코드 가독성,예측 가능한 코드,응집도 높은 구조,결합도 낮추기,리팩토링 팁,컴포넌트 설계,FE 아키텍처,React 디자인 패턴,Context API 활용,Composition 패턴,좋은 코드 기준,프론트엔드 클린코드,코드 품질 향상,개발 생산성,유지보수 쉬운 코드
tags:
  - frontend fundamentals
  - 클린코드
  - 코드리뷰
  - 코드리팩토링
  - FE 설계
  - React 패턴
  - 컴포넌트 설계
  - FE 아키텍처
  - 개발문화
  - 개발자 성장
  - 코드 품질
  - FE 생산성
  - 유지보수
  - 개발 팁
thumbnail: /blog/postImg/goodCodeThumbnail.png
permalink: blog/react/goodCodeFrontebd.md/
---

![좋은코드](/blog/postImg/goodCodeThumbnail.png)

## 토스FE의 좋은 코드를 위한 4가지 기준을 읽고나서.

먼저 토스의 4가지 기준에 대한 목차는 아래와 같다. 천천히 읽어가며 정리 후, 각 항목마다

내 생각을 덧붙이려한다. 

**읽기 귀찮으면 바로 5번의 정의로 가도 된다**

### 목차

##### 1. [가독성](#1-가독성)  
  - 맥락 줄이기
    - A. 같이 실행되지 않는 코드 분리하기
    - B. 구현 상세 추상화하기
    - C. 로직 종류에 따라 합쳐진 함수 쪼개기
  - 이름 붙이기
    - A. 복잡한 조건에 이름 붙이기
    - B. 매직 넘버에 이름 붙이기
  - 위에서 아래로 읽히게 하기
    - A. 시점 이동 줄이기
    - B. 삼항 연산자 단순하게 하기

##### 2. [예측 가능성](#2-예측가능성) 
  - A. 이름 겹치지 않게 관리하기
  - B. 같은 종류의 함수는 반환 타입 통일하기
  - C. 숨은 로직 드러내기

##### 3. [응집도](#3-응집도)  
  - A. 함께 수정되는 파일을 같은 디렉토리에 두기
  - B. 매직 넘버 없애기
  - C. 폼의 응집도 생각하기

##### 4. [결합도](#4-결합도)
  - A. 책임을 하나씩 관리하기
  - B. 중복 코드 허용하기
  - C. Props Drilling 지우기
  
##### 5. [정리](#5-정리)


---

# 결론: 변경하기 쉬운 코드가 좋은 FE 코드이다.

## 1. 가독성

 코드가 읽기 쉬운 정도를 말한다. 읽기 좋으면 변경하기도 쉽다는 것이다.

### 가독성을 높이려면

#### 1-1. 맥락 줄이기

 - **같이 실행되지 않는 코드 분리하기** : 하나의 함수 하나의 컴포넌트는 한가지 기능만 해야한다는 말이다. 코드가 길어진다고 생각하면 안된다. 가독성이 올라가는 것이다.
    - 단점 : 코드가 분리되다보면, 수정사항이 발생 할때마다 휴먼에러가 발생 할 가능성이 생긴다.
    - 보완 : 테스트 코드가 잘 짜여져 있다면 괜찮을거라는 생각이든다.

<br>

 - **구현 상세 추상화하기** : 불필요한 세부사항을 감추고, 핵심 로직만 드러내면 읽기 쉬워진다. 관련된 코드끼리 가까이 두어, 응집도를 높이고 실수도 줄일수 있다는 것이다.
    - "왼쪽으로 10걸음 걸어라"는 간단한 문장이지만, 세부적으로 풀면 매우 복잡해진다. 코드도 마찬가지로, 의도를 드러내는 간결한 표현이 더 이해하기 쉬워진다.
    - 토스에서는 두가지 방법을 제시했다.
        | 항목 | Wrapper 컴포넌트 (A) | HOC (B) |
        |------|---------------------|---------|
        | 적용 방식 | JSX에서 직접 감싸기 | 함수로 감싸서 새 컴포넌트 반환 |
        | 가독성 | 명시적, 구조 파악 쉬움 | 암묵적, 구조 파악 어려울 수 있음 |
        | 재사용성 | 중간 | 높음 |
        | 사용 용도 | UI 구조 조정에 적합 | 공통 로직 적용에 적합 |
        | url | [코드예시]([코드예시](https://frontend-fundamentals.com/code-quality/code/examples/login-start-page.html#%F0%9F%93%9D-%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3-%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5-1-loginstartpage) )  |

<br>

  - **로직 종류에 따라 합쳐진 함수 쪼개기** : 종류에 따라서  함수나 컴포넌트, Hook을 만들지 말라는 뜻이다. 너무 종류가 많아져서 이해하기 힘들다. 위에 코드분리와 비슷한 맥락이라고 판단된다.
         
<br>

#### 1-2. 이름붙이기

 - **복잡한 조건에 이름 붙이기** : 조건식에 이름을 알아보기 쉽게 지으라는 뜻. 예를들어 filter안에 가끔 여러 조건들이 있는데 그 조건들도 이름을 붙여서 변수처럼 사용하는 것이 가독성에 좋다.
    - 무조건 이름을 붙이라는건 아니다.
        1. 복잡한 로직을 다룰때 <-> 로직이 간단할 땐 그냥 냅두자
        2. 재사용성이 필요할 때 <-> 한번만 사용할 떈 굳이 안붙여도 좋다.
        3. 단위테스트가 필요할 때

<br>

 - **매직 넘버에 이름 붙이기** : 매직 넘버란, 정확한 뜻을 밝히지 않고 코드 안에 직접 숫자 값을 넣는것을 말한다. 예) 404, 86400초(하루 표현)
    - 예를들어 settimeout을 사용 할 때, 시간을 86400초 지정했다 치자. 또는 세션 만료시간을 지정했다쳐도, 어떤 목적으로 저런 숫자를 하였는지 단번에 알기 어렵다.
      - ONE_DAY = 86400 같은 방식으로 지정하자. 

<br>

#### 1-3. 위에서 아래로 읽히게 하기

 - **시점 이동 줄이기** : 코드를 위에서 아래로, 하나의 함수나 파일에서 읽을 수 있도록 코드를 작성하면, 읽는 사람이 동작을 빠르게 파악할 수 있다.
    - [관련 예시](https://frontend-fundamentals.com/code-quality/code/examples/user-policy.html)
 - **삼항 연산자 단순하게 하기** : 삼항 연산자를 복잡하게 사용하면 조건의 구조가 명확하게 보이지 않아서 코드를 읽기 어려울 수 있다.

<br>

---

## 2. 예측가능성

 이름이나, 같은 종류의 함수 등 은 예측가능해야한다는 말이다.

#### 2-1. 이름 겹치지 않게 관리하기
  - 같은 이름을 가지는 함수나 변수는 동일한 동작해야한다는 말이다.
  - 이런일은 거의 없다고 생각이 들긴하는데 확실히 이름을 지을때는 확실하게 잘 지어야하는것 같다.

<br>

#### 2-2. 같은 종류의 함수는 반환 타입 통일하기
  - 같은 역할을 하는 함수들이 서로 다른 반환 타입을 가지면, 코드를 사용할 때마다 "이건 뭐가 반환되지?" 하고 헷갈릴 수 이다.
  - 특히 협업할 때, 예측 가능성이 떨어지면 실수나 버그가 생기기 쉽다.
  - **같은 종류의 함수는 같은 모양의 결과를 줘야 코드를 쓰는 사람이 예측 가능하게 사용할 수 있다.**

 아래와 같은 방식으로 음식을 주문하는 같은 종류의 함수임에도 return 하는 타입이 달라, 예측이 힘들다.
```tsx
function getPizzaOrder() {
  const response =  {
    status: 'success',
    data: { name: 'Pepperoni', size: 'Large' }
  };

  return response
}

function getBurgerOrder() {
  const response =  {
    status: 'success',
    data: { name: 'Cheeseburger', size: 'Medium' }
  };
  
  return response.data
}
```
 - 둘중에 하나는 반드시 return 타입을 맞춰줘서 예측 가능하게 만들어 줘야한다.

<br>

#### 2-3. 숨은 로직 드러내기

  - 예를들어 fetchUser() 라는 함수에 로그를 부분까지 있다고 하면,함수 이름이나 반환 타입만 봐서는 로깅이 있다는 걸 알 수 없다.
  - 로깅시스템이 에러나면 유저데이터를 가지고오는 곳도 에러가 날 수 있다.
  - 함수는 순수하게 데이터만 패칭하고, 로깅은 따로 빼서 로그를 남기는 것이 좋다.
  

---

## 3. 응집도

 이름이나, 같은 종류의 함수 등 은 예측가능해야한다는 말이다.

#### 3-1. 함께 수정되는 파일을 같은 디렉토리에 두기
  - 도메인 별로 디렉터리 구조를 분리하는 방법, FSD 아키텍처의 Slice 개념에서 사용하는 방법이라고 볼 수 있다.
  - [FSD란?](https://feature-sliced.design/kr/docs/get-started/overview)
  - 관심사의 분리라고도 볼 수 있겠다.

<br>

#### 3-2. 폼의 응집도 생각하기
  - Form을 관리할 때는 2가지의 방법으로 응집도를 관리해서, 함께 수정되어야 할 코드가 함께 수정되도록 할 수 있다.
    - 필드 단위 응집도 :  개별 입력 요소를 독립적으로 관리하는 방식,  각 필드가 고유의 검증 로직을 가지므로 유지보수가 쉽다. 다른필드에 영향도 줄어든다.

    - 폼 전체 단위 응집도 : 모든 필드의 검증 로직이 폼에 종속되는 방식, 폼 전체에서의 흐름을 고려하여 설계되며, 변경 단위가 폼 단위로 발생할 때 고려
                            폼 전체의 검증이 한 곳에서 관리되어 로직이 간결,  상태가 중앙 집중식으로 관리되므로 폼 전체 흐름을 이해하기 쉬움, 재사용성은 떨어짐


---

## 4. 결합도

 이름이나, 같은 종류의 함수 등 은 예측가능해야한다는 말이다.

#### 4-1. 중복 코드 허용하기
  -  여러 페이지나 컴포넌트에 걸친 중복 코드를 하나의 Hook이나 컴포넌트로 공통화하는 경우가 많다.  중복 코드를 하나의 컴포넌트나 Hook으로 공통화하면, 좋은 코드의 특징 중 하나인 응집도를 챙겨서, 함께 수정되어야 할 코드들을 한꺼번에 수정할 수 있다.
  - 불필요한 결합도가 생겨서, 공통 컴포넌트나 Hook을 수정함에 따라 영향을 받는 코드의 범위가 넓어져서, 오히려 수정이 어려워질 수도 있다.
  - 처음에는 비슷하게 동작한다고 생각해서 공통화한 코드가, 이후 페이지마다 다른 특이한 요구사항이 생겨서, 점점 복잡해질 수 있다......ㅜㅜ

**결론적으로는 중복코드를 허용하는 것이 좋은 방향일 수 있다. 잘 판단해야한다.** 

#### 4-2. Props Drilling 지우기
  -  ✅ A. 조합(Composition) 패턴
    - children을 활용해서 컴포넌트를 조립하듯 구성.
    - 부모가 자식에게 필요한 UI를 직접 넘겨주므로 유연한 구조를 만들 수 있음.
    - 하지만 깊은 컴포넌트 트리에서는 여전히 props를 여러 단계로 전달해야 하는 Props Drilling 문제가 발생할 수 있음.

<br>

  - ✅ B. Context API
    - 전역 상태처럼 데이터를 공유할 수 있는 방법.
    - 중간 컴포넌트에 props를 전달하지 않아도 되므로 Props Drilling 완전 제거 가능.
    - 복잡한 컴포넌트 구조에서도 데이터 흐름이 깔끔해짐.


---

## 5. 정리

가독성, 예측 가능성, 응집도, 결합도 네가지 모두 서로 연결되어있다는것을 알 수 있었다.

**가독성은 출발점: 코드가 읽기 쉬워야 다른 기준들도 작동한다. 예측 가능성도 결국은 읽고 이해할 수 있어야 생기니까.**

**예측 가능성은 안정성: 협업과 유지보수에서 실수를 줄이는 핵심. 반환 타입 통일, 숨은 로직 제거 등은 모두 안정성을 높이는 전략.**

**응집도는 구조의 품질: 함께 수정되는 코드가 함께 있어야 변경이 쉬워지고, 실수도 줄어든다. 이는 곧 생산성과 연결됨.**

**결합도는 유연성의 척도: 너무 높으면 수정이 어렵고, 너무 낮으면 중복이 생긴다. 적절한 결합도는 좋은 설계의 핵심.**

## 🔄 네 가지 기준의 상호작용

| 기준       | 핵심 개념                         | 서로 연결되는 방식                                                                 |
|------------|----------------------------------|------------------------------------------------------------------------------------|
| **가독성**   | 코드를 쉽게 읽고 이해할 수 있음     | - 예측 가능성이 높으면 가독성도 향상됨<br>- 응집도가 높으면 관련 코드가 가까이 있어 읽기 쉬움 |
| **예측 가능성** | 코드의 동작을 예상할 수 있음       | - 가독성이 높으면 코드 흐름을 쉽게 파악 가능<br>- 결합도가 낮으면 코드 변경 시 영향 범위 예측 쉬움 |
| **응집도**   | 관련된 기능이 함께 모여 있음        | - 가독성과 예측 가능성을 높여줌<br>- 결합도를 낮추는 데 도움됨                              |
| **결합도**   | 컴포넌트 간 의존성의 정도           | - 낮은 결합도는 예측 가능성과 유지보수성 향상<br>- 응집도와 균형을 맞춰야 함 (너무 낮으면 중복 증가) |
