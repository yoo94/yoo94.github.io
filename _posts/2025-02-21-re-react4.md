---
layout: post
title: "리액트 up 3. useReducer 구조와 원리"
summary: "모든 useSTate는 useReducer로 대체 가능"
author: yoo94
date: '2025-02-21 1:32:23 +0530'
category: ['react-up']
tags:
  - 리액트
  - react
  - 공부
  - 코딩
  - 이직
  - front end
  - 프론트엔드
  - useReducer
thumbnail: 
permalink: blog/react/react-up4/
---

#### useReducer 구조와 원리

useReducer는 리액트에서 상태 관리를 위해 사용하는 또 다른 훅이다.
이 훅은 상태와 디스패치 함수를 반환하며, **상태를 업데이트하기 위해 액션을 디스패치하는 방식으로 작동.**
이 구조는 복잡한 상태 로직을 관리할 때 유용하다.
예를 들어, useReducer는 다음과 같이 사용할 수 있다.

[useReducer 개념](/blog/react-hook-useReducer/)

```javascript   
import React, { useReducer } from 'react';

export const countState = {
  count: 0,
};

export function countReducer(state, action) { <- 함수이름은 맘대로
  switch (action.type) {
    case 'increment':
      return { count: state.count + action.payload };
    case 'decrement':
      return { count: state.count - action.payload };
    default:
      throw new Error();
  }
}
function Counter() {
  const [state, dispatch] = useReducer(countReducer, countState);

  return (
    <div>
      <p>현재 카운트: {state.count}</p>
      <button onClick={(e) => dispatch({ type: 'increment' , payload: e.target.value })}>증가</button>
      <button onClick={(e) => dispatch({ type: 'decrement', payload: e.target.value  })}>감소</button>
    </div>
  );
}
export default Counter;
```

1. **reducer 함수**: 상태 업데이트 로직을 정의하는 함수로, 현재 상태와 액션을 인자로 받아 새로운 상태를 반환한다.
2. **useReducer 훅**: 상태와 디스패치 함수를 반환하며, 초기 상태를 두 번째 인자로 받는다.
3. **dispatch 함수**: 액션을 디스패치하여 상태를 업데이트하는 함수로, 액션 객체를 인자로 받는다.
4. **상태 업데이트**: 액션이 디스패치되면, reducer 함수가 호출되어 새로운 상태를 반환하고, 컴포넌트는 이 새로운 상태로 리렌더링된다.
5. **컴포넌트 리렌더링**: 상태가 변경되면, 리액트는 해당 컴포넌트를 리렌더링하여 UI를 업데이트한다.
6. **에러 처리**: 기본적으로, reducer 함수에서 알 수 없는 액션 타입이 전달되면 에러를 발생시킨다. 이는 디버깅에 도움이 된다.
7. **디버깅 용이성**: useReducer는 상태 업데이트 로직을 명확하게 분리하므로, 디버깅이 용이하다. 각 액션에 대한 상태 변경을 추적하기 쉽다.
8. **컴포넌트 재사용성**: useReducer를 사용하면 상태 관리 로직을 별도의 함수로 분리할 수 있어, 컴포넌트의 재사용성이 높아진다. 여러 컴포넌트에서 동일한 상태 관리 로직을 공유할 수 있다.
9. **상태 초기화**: useReducer는 초기 상태를 두 번째 인자로 받으며, 이 초기 상태는 컴포넌트가 처음 렌더링될 때 사용된다. 이후 상태 업데이트는 reducer 함수를 통해 이루어진다.
10. **의존성 관리**: useReducer는 상태 업데이트 로직을 명확하게 분리하므로, 의존성 관리가 용이하다. 상태 업데이트 로직이 복잡한 경우, useReducer를 사용하여 의존성을 명확하게 정의할 수 있다.
11. **비동기 작업 처리**: useReducer는 비동기 작업을 처리할 때 유용하다. 액션을 디스패치하여 상태를 업데이트하고, 비동기 작업이 완료되면 다시 액션을 디스패치하여 상태를 업데이트할 수 있다. 이를 통해 비동기 작업의 결과를 쉽게 관리할 수 있다.